<html>
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /></head>
<body>
<p>
Carrot<sup>2</sup> is an Open Source Search Results Clustering Engine, which can
automatically organize small collections of documents, for example search results,
into thematic categories, <a href="#overview_description">see below for more</a>.
</p>

<h1>Downloads &amp; more information</h1>
<p>
<a href="http://project.carrot2.org/download-java-api.html" class="download-small">Java API JAR, JavaDocs and example code</a><br />
<a href="http://project.carrot2.org/download.html" class="download-small">Other Carrot2 applications</a><br />
<a href="http://download.carrot2.org/head/manual/index.html" class="view-small">User and Developer Manual</a><br />
<a href="http://download.carrot2.org/head/manual/index.html#section.integration.adding-to-maven-project" class="view-small">Instructions for Maven2 users</a><br />
<a href="http://project.carrot2.org" class="view-small">Carrot2 project website</a><br />
<a href="http://search.carrot2.org" class="view-small">Carrot2 on-line demo</a>
</p>

<h1>Java API usage examples</h1>
<p>
  You can use Carrot<sup>2</sup> Java API to fetch documents from various sources (public search engines, Lucene, Solr), perform clustering, serialize the results to JSON or XML and many more. Below is some example code for the most common use cases. Please see the <tt>examples/</tt> directory in the <a href="http://project.carrot2.org/download-java-api.html">Java API distribution archive</a> for more examples.
</p>

<a name="clustering-from-document-sources"></a>
<h2>Clustering documents from document sources</h2>
<p>
The most common way to use Carrot<sup>2</sup> Java API is to fetch a number of
documents from some {@link org.carrot2.core.IDocumentSource} and cluster them
using some {@link org.carrot2.core.IClusteringAlgorithm}. The general pattern
for this kind of invocation is to put all input data required for processing
(query and required number of results in this case) into a map and pass that
map to an {@link org.carrot2.core.Controller} that will perform all the processing.
The code shown below retrieves 100 search results from {@link org.carrot2.source.microsoft.BingDocumentSource}
and clusters them using the {@link org.carrot2.clustering.lingo.LingoClusteringAlgorithm}.
</p>

<pre class="brush: java">
        /* A controller to manage the processing pipeline. */
        Controller controller = ControllerFactory.createSimple();

        /* Input data for clustering, the query and number of results in this case. */
        Map&lt;String, Object> attributes = new HashMap&lt;String, Object>();
        attributes.put(AttributeNames.QUERY, "data mining");
        attributes.put(AttributeNames.RESULTS, 100);

        /* Perform processing */
        ProcessingResult result = controller.process(attributes,
            BingDocumentSource.class, LingoClusteringAlgorithm.class);
        
        /* Documents fetched from the document source, clusters created by Carrot2. */
        List&lt;Document> documents = result.getDocuments();
        List&lt;Cluster> clusters = result.getClusters();
</pre>
<a class="source-link" href="http://fisheye3.atlassian.com/browse/carrot2/trunk/applications/carrot2-examples/src/org/carrot2/examples/clustering/ClusteringDataFromDocumentSources.java?r=trunk">View full source code</a>

<a name="clustering-documents"></a>
<h2>Clustering arbitrary documents</h2>

<p>
You can also directly pass a list of {@link org.carrot2.core.Document} instances for clustering:
</p>

<pre class="brush: java">
        /* A few example documents, normally you would need at least 20 for reasonable clusters. */
        final String [][] data = new String [] []
        {
            {
                "http://en.wikipedia.org/wiki/Data_mining",
                "Data mining - Wikipedia, the free encyclopedia",
                "Article about knowledge-discovery in databases (KDD), the practice of automatically searching large stores of data for patterns."
            },

            {
                "http://www.ccsu.edu/datamining/resources.html",
                "CCSU - Data Mining",
                "A collection of Data Mining links edited by the Central Connecticut State University ... Graduate Certificate Program. Data Mining Resources. Resources. Groups ..."
            },

            {
                "http://www.kdnuggets.com/",
                "KDnuggets: Data Mining, Web Mining, and Knowledge Discovery",
                "Newsletter on the data mining and knowledge industries, offering information on data mining, knowledge discovery, text mining, and web mining software, courses, jobs, publications, and meetings."
            },

            {
                "http://en.wikipedia.org/wiki/Data-mining",
                "Data mining - Wikipedia, the free encyclopedia",
                "Data mining is considered a subfield within the Computer Science field of knowledge discovery. ... claim to perform \"data mining\" by automating the creation ..."
            },

            {
                "http://www.anderson.ucla.edu/faculty/jason.frand/teacher/technologies/palace/datamining.htm",
                "Data Mining: What is Data Mining?",
                "Outlines what knowledge discovery, the process of analyzing data from different perspectives and summarizing it into useful information, can do and how it works."
            },
        };
        ArrayList&lt;Document> documents = new ArrayList&lt;Document>();
        for (String [] row : data)
        {
            documents.add(new Document(row[1], row[2], row[0]));
        }

        /* A controller to manage the processing pipeline. */
        SimpleController controller = new SimpleController();

        /* Input data for clustering, list of Documents in this case. */
        Map&lt;String, Object> attributes = new HashMap&lt;String, Object>();
        attributes.put(AttributeNames.DOCUMENTS, documents);

        /* Perform clustering */
        ProcessingResult result = controller.process(attributes,
            LingoClusteringAlgorithm.class);
  
        /* Clusters created by Carrot2. */
        List&lt;Cluster> clusters = result.getClusters();
</pre>
<a class="source-link" href="http://fisheye3.atlassian.com/browse/carrot2/trunk/applications/carrot2-examples/src/org/carrot2/examples/clustering/ClusteringDocumentList.java?r=trunk">View full source code</a>

<a name="caching-controller"></a>
<h2>Pooling of processing component instances, caching of processing results</h2>

<p>
  The examples above used a simple controller 
  to manage the clustering process. While the simple controller
  is enough for one-shot requests, for long-running applications, such as web 
  applications, it's better to use a controller which supports pooling of 
  processing component instances and caching of processing results. 
</p>

<pre class="brush: java">
        /*
         * Create the caching controller. You need only one caching controller instance
         * per application life cycle. This controller instance will cache the results
         * fetched from any document source and also clusters generated by the Lingo
         * algorithm.
         */
        Controller controller = ControllerFactory.createCachingPooling(
            IDocumentSource.class, LingoClusteringAlgorithm.class);

        /*
         * Before using the caching controller, you must initialize it. On initialization,
         * you can set default values for some attributes. In this example, we'll set 
         * the default results number to 50.
         */
        Map&lt;String, Object> globalAttributes = new HashMap&lt;String, Object>();
        globalAttributes.put(AttributeNames.RESULTS, 50);
        controller.init(globalAttributes);

        /*
         * The controller is now ready to perform queries. To show that the documents from
         * the document input are cached, we will perform the same query twice and measure
         * the time for each query.
         */
        Map&lt;String, Object> attributes;
        ProcessingResult result;
        long start, duration;
        
        start = System.currentTimeMillis();
        attributes = new HashMap&lt;String, Object>();
        attributes.put(AttributeNames.QUERY, "data mining");
        result = controller.process(attributes,
            BingDocumentSource.class, LingoClusteringAlgorithm.class);
        duration = System.currentTimeMillis() - start;
        System.out.println(duration + " ms (empty cache)");
        
        start = System.currentTimeMillis();
        attributes = new HashMap&lt;String, Object>();
        attributes.put(AttributeNames.QUERY, "data mining");
        result = controller.process(attributes,
            BingDocumentSource.class, LingoClusteringAlgorithm.class);
        duration = System.currentTimeMillis() - start;
        System.out.println(duration + " ms (documents and clusters from cache)");
</pre>
<a class="source-link" href="http://fisheye3.atlassian.com/browse/carrot2/trunk/applications/carrot2-examples/src/org/carrot2/examples/clustering/UsingCachingController.java?r=trunk">View full source code</a>

<a name="non-english"></a>
<h2>Clustering non-English content</h2>

<p>
This example shows how to cluster non-English content. By default Carrot2 assumes that
the documents provided for clustering are written in English. When clustering content
written in some different language, it is important to indicate the language to
Carrot2, so that it can use the lexical resources (stop words, tokenizer, stemmer)
appropriate for that language.
</p>

<p>
There are two ways to indicate the desired clustering language to Carrot2:
</p>

<ol>
<li>By setting the language of each document in their
{@link org.carrot2.core.Document#LANGUAGE} field. The language does not necessarily
have to be the same for all documents on the input, Carrot2 can handle multiple
languages in one document set as well. Please see the
{@link org.carrot2.text.clustering.MultilingualClustering#languageAggregationStrategy}
attribute for more details.</li>
<li>By setting the fallback language. For documents with undefined
{@link org.carrot2.core.Document#LANGUAGE} field, Carrot2 will assume the some fallback
language, which is English by default. You can change the fallback language by setting
the {@link org.carrot2.text.clustering.MultilingualClustering#defaultLanguage}
attribute.
</ol>
Additionally, a number of document sources automatically set the
{@link org.carrot2.core.Document#LANGUAGE} of documents they produce based on their
specific language-related attributes. Currently, three documents support this scenario:
<ol>
<li>{@link org.carrot2.source.microsoft.BingDocumentSource} through the
{@link org.carrot2.source.microsoft.BingDocumentSource#market} attribute</li>
<li>{@link org.carrot2.source.boss.BossDocumentSource} through the
{@link org.carrot2.source.boss.BossSearchService#languageAndRegion} attribute</li>
<li>{@link org.carrot2.source.etools.EToolsDocumentSource} through the
{@link org.carrot2.source.etools.EToolsDocumentSource#language} attribute</li>
</ol>

<p>
For the document sources that do not set the documents' language automatically, the
easiest way to set the clustering language is through the
{@link org.carrot2.text.clustering.MultilingualClustering#defaultLanguage} attribute.
</p>

<p>
  The following example demonstrates both approaches:
</p>

<pre class="brush: java">
/*
 * We use a CachingController to reuse instances of Carrot2 processing components.
 */
Controller controller = ControllerFactory.createCachingPooling(IDocumentSource.class);

/*
 * No special initialization-time attributes in this example.
 */
final Map&lt;String, Object> initAttributes = new HashMap&lt;String, Object>();
controller.init(initAttributes);

/*
 * In the first call, we'll cluster a document list, setting the language for each
 * document separately.
 */
final List&lt;Document> documents = Lists.newArrayList();
for (Document document : SampleDocumentData.DOCUMENTS_DATA_MINING)
{
  documents.add(new Document(document.getTitle(), document.getSummary(),
    document.getContentUrl(), LanguageCode.ENGLISH));
}

final Map&lt;String, Object> attributes = new HashMap&lt;String, Object>();
attributes.put(AttributeNames.DOCUMENTS, documents);
final ProcessingResult englishResult = controller.process(attributes,
  LingoClusteringAlgorithm.class);
ConsoleFormatter.displayResults(englishResult);

/*
 * In the second call, we will fetch results for a Chinese query from MSN Live,
 * setting explicitly the MSN Live's specific language attribute. Based on that
 * attribute, the document source will set the appropriate language for each
 * document.
 */
attributes.clear();
attributes.put(AttributeNames.QUERY, "聚类"); // clustering?
attributes.put("BingDocumentSource.market", MarketOption.CHINESE_CHINA);
attributes.put(AttributeNames.RESULTS, 100);
final ProcessingResult chineseResult = controller.process(attributes,
  BingDocumentSource.class, LingoClusteringAlgorithm.class);
ConsoleFormatter.displayResults(chineseResult);

/*
 * In the third call, we will fetch results for the same Chinese query from
 * Google. As Google document source does not have its specific attribute for
 * setting the language, it will not set the documents' language for us. To make
 * sure the right lexical resources are used, we will need to set the
 * MultilingualClustering.defaultLanguage attribute to Chinese on our own.
 */
attributes.clear();
attributes.put(AttributeNames.QUERY, "聚类"); // clustering?
attributes.put("MultilingualClustering.defaultLanguage",
  LanguageCode.CHINESE_SIMPLIFIED);
attributes.put(AttributeNames.RESULTS, 100);
final ProcessingResult chineseResult2 = controller.process(attributes,
  GoogleDocumentSource.class, LingoClusteringAlgorithm.class);
ConsoleFormatter.displayResults(chineseResult2);
</pre>
<a class="source-link" href="http://fisheye3.atlassian.com/browse/carrot2/trunk/applications/carrot2-examples/src/org/carrot2/examples/clustering/ClusteringNonEnglishContent.java?r=trunk">View full source code</a>
<p>
&nbsp;
</p>

<link type="text/css" rel="stylesheet" href="{@docRoot}/sh/shCore.css"/>
<link type="text/css" rel="stylesheet" href="{@docRoot}/sh/shThemeDefault.css"/>
<script type="text/javascript" src="{@docRoot}/sh/shCore.js"></script>
<script type="text/javascript" src="{@docRoot}/sh/shBrushJava.js"></script>
<script type="text/javascript">
  SyntaxHighlighter.defaults.light = false;
  SyntaxHighlighter.defaults.gutter = false;
  SyntaxHighlighter.all();
</script>

</body>
</html>
