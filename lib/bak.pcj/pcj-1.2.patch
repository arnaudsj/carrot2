Index: src/bak/pcj/list/IntArrayList.java
===================================================================
--- src/bak/pcj/list/IntArrayList.java	(revision 1)
+++ src/bak/pcj/list/IntArrayList.java	(revision 2)
@@ -63,13 +63,13 @@
     public static final int    DEFAULT_CAPACITY             = 10;
 
     /** The elements of this list (indices <tt>0</tt> to <tt>size-1</tt>). */
-    private transient int[] data;
+    protected transient int[] data;
 
     /**
      *  The current size of this list. 
      *  @serial
      */
-    private int size;
+    protected int size;
 
     /**
      *  The growth policy of this list (0 is relative growth, 1 is absolute growth).
Index: src/bak/pcj/map/IntKeyIntOpenHashMap.java
===================================================================
--- src/bak/pcj/map/IntKeyIntOpenHashMap.java	(revision 1)
+++ src/bak/pcj/map/IntKeyIntOpenHashMap.java	(revision 2)
@@ -1,6 +1,6 @@
 /*
  *  Primitive Collections for Java.
- *  Copyright (C) 2002, 2003  S�ren Bak
+ *  Copyright (C) 2002, 2003  S?ren Bak
  *
  *  This library is free software; you can redistribute it and/or
  *  modify it under the terms of the GNU Lesser General Public
@@ -76,37 +76,37 @@
      *  The hash function used to hash keys in this map.
      *  @serial
      */
-    private IntHashFunction keyhash;
+    protected IntHashFunction keyhash;
 
     /**
      *  The size of this map.
      *  @serial
      */
-    private int size;
+    protected int size;
 
     /**
      *  The keys of this map. Contains key values directly.
      *  Due to the use of a secondary hash function, the length of this
      *  array must be a prime.
      */
-    private transient int[] keys;
+    protected transient int[] keys;
 
     /**
      *  The values of this map. Contains values directly.
      *  Due to the use of a secondary hash function, the length of this
      *  array must be a prime.
      */
-    private transient int[] values;
+    protected transient int[] values;
 
     /** The states of each cell in the keys[] and values[]. */
-    private transient byte[] states;
+    protected transient byte[] states;
 
-    private static final byte EMPTY = 0;
-    private static final byte OCCUPIED = 1;
-    private static final byte REMOVED = 2;
+    protected static final byte EMPTY = 0;
+    protected static final byte OCCUPIED = 1;
+    protected static final byte REMOVED = 2;
 
     /** The number of entries in use (removed or occupied). */
-    private transient int used;
+    protected transient int used;
 
     /**
      *  The growth policy of this map (0 is relative growth, 1 is absolute growth).
@@ -141,16 +141,16 @@
     private int expandAt;
 
     /** A set view of the keys of this map. */
-    private transient IntSet ckeys;
+    protected transient IntSet ckeys;
 
     /** A collection view of the values of this map. */
-    private transient IntCollection cvalues;
+    protected transient IntCollection cvalues;
 
     /** Indicates whether last call to containsKey() had a corresponding value. */
-    private transient boolean hasLastValue;
+    protected transient boolean hasLastValue;
     
     /** Value corresponding to to the key of the last call of containsKey(). */
-    private transient int lastValue;
+    protected transient int lastValue;
 
     private IntKeyIntOpenHashMap(IntHashFunction keyhash, int capacity, int growthPolicy, double growthFactor, int growthChunk, double loadFactor) {
         if (keyhash == null)
@@ -458,7 +458,7 @@
     //      Hash table management
     // ---------------------------------------------------------------
 
-    private void ensureCapacity(int elements) {
+    protected void ensureCapacity(int elements) {
         if (elements >= expandAt) {
             int newcapacity;
             if (growthPolicy == GROWTH_POLICY_RELATIVE)
Index: src/bak/pcj/map/LongKeyIntOpenHashMap.java
===================================================================
--- src/bak/pcj/map/LongKeyIntOpenHashMap.java	(revision 1)
+++ src/bak/pcj/map/LongKeyIntOpenHashMap.java	(revision 2)
@@ -1,6 +1,6 @@
 /*
  *  Primitive Collections for Java.
- *  Copyright (C) 2002, 2003  S�ren Bak
+ *  Copyright (C) 2002, 2003  S�ren Bak
  *
  *  This library is free software; you can redistribute it and/or
  *  modify it under the terms of the GNU Lesser General Public
@@ -76,37 +76,37 @@
      *  The hash function used to hash keys in this map.
      *  @serial
      */
-    private LongHashFunction keyhash;
+    protected LongHashFunction keyhash;
 
     /**
      *  The size of this map.
      *  @serial
      */
-    private int size;
+    protected int size;
 
     /**
      *  The keys of this map. Contains key values directly.
      *  Due to the use of a secondary hash function, the length of this
      *  array must be a prime.
      */
-    private transient long[] keys;
+    protected transient long[] keys;
 
     /**
      *  The values of this map. Contains values directly.
      *  Due to the use of a secondary hash function, the length of this
      *  array must be a prime.
      */
-    private transient int[] values;
+    protected transient int[] values;
 
     /** The states of each cell in the keys[] and values[]. */
-    private transient byte[] states;
+    protected transient byte[] states;
 
-    private static final byte EMPTY = 0;
-    private static final byte OCCUPIED = 1;
-    private static final byte REMOVED = 2;
+    protected static final byte EMPTY = 0;
+    protected static final byte OCCUPIED = 1;
+    protected static final byte REMOVED = 2;
 
     /** The number of entries in use (removed or occupied). */
-    private transient int used;
+    protected transient int used;
 
     /**
      *  The growth policy of this map (0 is relative growth, 1 is absolute growth).
@@ -141,16 +141,16 @@
     private int expandAt;
 
     /** A set view of the keys of this map. */
-    private transient LongSet ckeys;
+    protected transient LongSet ckeys;
 
     /** A collection view of the values of this map. */
-    private transient IntCollection cvalues;
+    protected transient IntCollection cvalues;
 
     /** Indicates whether last call to containsKey() had a corresponding value. */
-    private transient boolean hasLastValue;
+    protected transient boolean hasLastValue;
     
     /** Value corresponding to to the key of the last call of containsKey(). */
-    private transient int lastValue;
+    protected transient int lastValue;
 
     private LongKeyIntOpenHashMap(LongHashFunction keyhash, int capacity, int growthPolicy, double growthFactor, int growthChunk, double loadFactor) {
         if (keyhash == null)
@@ -458,7 +458,7 @@
     //      Hash table management
     // ---------------------------------------------------------------
 
-    private void ensureCapacity(int elements) {
+    protected void ensureCapacity(int elements) {
         if (elements >= expandAt) {
             int newcapacity;
             if (growthPolicy == GROWTH_POLICY_RELATIVE)
Index: src/bak/pcj/set/IntBitSet.java
===================================================================
--- src/bak/pcj/set/IntBitSet.java	(revision 1)
+++ src/bak/pcj/set/IntBitSet.java	(revision 2)
@@ -1,6 +1,6 @@
 /*
  *  Primitive Collections for Java.
- *  Copyright (C) 2002, 2003  S�ren Bak
+ *  Copyright (C) 2002, 2003  S?ren Bak
  *
  *  This library is free software; you can redistribute it and/or
  *  modify it under the terms of the GNU Lesser General Public
@@ -47,22 +47,22 @@
  */
 public class IntBitSet extends AbstractIntSet implements IntSortedSet, Cloneable, Serializable {
 
-    private static final int BITS_PER_LONG = 64;
-    private static final int BIT_MASK = 0x0000003F;
-    private static final int BIT_MASK_BITS = 6;
-    private static final int DEFAULT_CAPACITY = BITS_PER_LONG;
+    protected static final int BITS_PER_LONG = 64;
+    protected static final int BIT_MASK = 0x0000003F;
+    protected static final int BIT_MASK_BITS = 6;
+    protected static final int DEFAULT_CAPACITY = BITS_PER_LONG;
 
     /**
      *  The array of bits backing up this set.
      *  @serial
      */
-    private long[] data;
+    protected long[] data;
 
     /**
      *  The size of this set.
      *  @serial
      */
-    private int size;
+    protected int size;
 
     /**
      *  Creates a new bit set with a specified maximum value.
@@ -132,7 +132,7 @@
             add(a[i]);
     }
 
-    private static int amax(int[] a) {
+    protected static int amax(int[] a) {
         int max = (int)0;
         for (int i = 0; i < a.length; i++)
             if (a[i] > max) max = a[i];
@@ -143,16 +143,16 @@
     //      Bit management
     // ---------------------------------------------------------------
 
-    private static int longIndex(int index)
+    protected static int longIndex(int index)
     { return index >> BIT_MASK_BITS; }
 
-    private static int bitIndex(int index)
+    protected static int bitIndex(int index)
     { return index & BIT_MASK; }
 
-    private static long bit(int bitno)
+    protected static long bit(int bitno)
     { return 1L << bitno; }
 
-    private static int largestBitIndexOf(long v) {
+    protected static int largestBitIndexOf(long v) {
         if (v == 0L)
             throw new IllegalArgumentException("No elements left");
         int bitIndex = BITS_PER_LONG-1;
@@ -164,7 +164,7 @@
         return bitIndex;
     }
 
-    private static int smallestBitIndexOf(long v) {
+    protected static int smallestBitIndexOf(long v) {
         if (v == 0L)
             throw new IllegalArgumentException("No elements left");
         int bitIndex = 0;
@@ -176,7 +176,12 @@
         return bitIndex;
     }
 
-    private static int countBits(long v) {
+    protected static int countBits(long v) {
+        if (v == 0)
+        {
+            return 0;
+        }
+        
         int count = 0;
         int bitIndex = 0;
         long bit = 1L;
@@ -189,14 +194,14 @@
         return count;
     }
 
-    private static long lowMask(int n) {
+    protected static long lowMask(int n) {
         long v = 0L;
         for (int i = 0; i < n; i++)
             v = (v << 1) | 1L;
         return v;
     }
 
-    private static long highMask(int n) {
+    protected static long highMask(int n) {
         return ~lowMask(n);
     }
 
@@ -261,6 +266,7 @@
             int nextLongIndex = nextLongIndex(0);
             int nextBitIndex = nextLongIndex < data.length ? nextBitIndex(nextLongIndex, 0) : 0;
             int lastValue = -1;
 
             int nextLongIndex(int index) {
                 while (index < data.length && data[index] == 0)
@@ -279,12 +285,13 @@
             }
 
             public boolean hasNext() {
                 return nextLongIndex < data.length;
             }
 
             public int next() {
                 if (!hasNext())
                     Exceptions.endOfIterator();
                 lastValue = (int)(nextLongIndex*BITS_PER_LONG + nextBitIndex);
 
                 //  Advance pointers
@@ -384,11 +391,12 @@
     public int size()
     { return size; }
 
+
     // ---------------------------------------------------------------
     //      Sorted set operations
     // ---------------------------------------------------------------
 
-    private int firstFrom(int from) {
+    protected int firstFrom(int from) {
         if (size == 0)
             Exceptions.setNoFirst();
         int longIndex = longIndex(from);
@@ -418,7 +426,7 @@
         return firstFrom((int)0);
     }
 
-    private int lastFrom(int from) {
+    protected int lastFrom(int from) {
         if (size == 0)
             Exceptions.setNoLast();
         int longIndex = Math.min(longIndex(from), data.length-1);
@@ -700,4 +708,4 @@
 
     }
 
-}
\ No newline at end of file
+}
